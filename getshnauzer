if not getgenv().AutoGet then
    getgenv().AutoGet = true

    local router
    for i, v in next, getgc(true) do
        if type(v) == 'table' and rawget(v, 'get_remote_from_cache') then
            router = v
        end
    end
    
    local function rename(remotename, hashedremote)
        hashedremote.Name = remotename
    end
    
    table.foreach(debug.getupvalue(router.get_remote_from_cache, 1), rename)
    
    local ClientData = require(game:GetService("ReplicatedStorage").ClientModules.Core.ClientData)
    local playerName = game.Players.LocalPlayer.Name
    local playerData = ClientData.get_data()[playerName]
    local candies = ClientData.get_data()[playerName].gingerbread_2025
    local totalBoxes = math.floor(candies / 80000)
    local ShopAPI = game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("ShopAPI/BuyItem")

    for i = 1, math.ceil(totalBoxes / 99) do
        local buyCount = math.min(99, totalBoxes - (i - 1) * 99)
        if buyCount <= 0 then break end
        ShopAPI:InvokeServer("pets", "winter_2025_maine_coon", { buy_count = buyCount })
        task.wait(0.5)
    end

    task.wait(1)
    game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("HousingAPI/ClaimAllDeliveries"):FireServer()
    task.wait(1)

    -- Trade License
    -- task.wait(1)
    -- fsys = require(game.ReplicatedStorage:WaitForChild("Fsys")).load
    -- fsys("RouterClient").get("SettingsAPI/SetBooleanFlag"):FireServer("has_talked_to_trade_quest_npc", true)
    -- task.wait()
    -- fsys("RouterClient").get("TradeAPI/BeginQuiz"):FireServer()
    -- task.wait(1)
    
    -- for i, v in pairs(fsys('ClientData').get("trade_license_quiz_manager")["quiz"]) do
    --     fsys("RouterClient").get("TradeAPI/AnswerQuizQuestion"):FireServer(v["answer"])
    --     task.wait()
    -- end
    
    local ClientData = require(game:GetService("ReplicatedStorage").ClientModules.Core.ClientData)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local CreatePetObject = ReplicatedStorage:WaitForChild("API"):WaitForChild("PetObjectAPI/CreatePetObject")
    local EquipPet = ReplicatedStorage:WaitForChild("API"):WaitForChild("ToolAPI/Equip")
    
    -- Collect potions
    local food = ClientData.get_data()[game.Players.LocalPlayer.Name].inventory.food
    local potions = {}
    for _, item in pairs(food) do
        if item.id == "pet_age_potion" then
            table.insert(potions, item.unique)
        end
    end
    
    -- Collect Super Sarus
    local petsdata = ClientData.get_data()[game.Players.LocalPlayer.Name].inventory.pets
    local saruUniques = {}
    for _, pet in pairs(petsdata) do
        if pet.id == "winter_2025_xmas_tree_sasquatch" or pet.id == "winter_2025_maine_coon" then
            table.insert(saruUniques, pet.unique)
        end
    end
    
    -- Only feed 16 or less depending on available pets and potions
    local targetCount = 100
    local maxRuns = math.min(targetCount, #saruUniques, math.floor(#potions / 7))
    
    print("‚öôÔ∏è Feeding " .. maxRuns .. " Super Sarus with 10 potions each")
    
    for i = 1, maxRuns do
        local petUnique = saruUniques[i]
    
        -- Equip Saru
        local equipArgs = {
            [1] = petUnique,
            [2] = { use_sound_delay = true, equip_as_last = false }
        }
    
        local equipped = pcall(function()
            return EquipPet:InvokeServer(unpack(equipArgs))
        end)
    
        if equipped then
            print("‚úÖ Equipped Super Saru #" .. i .. ": " .. petUnique)
        else
            warn("‚ùå Failed to equip Super Saru #" .. i)
            continue
        end
    
        task.wait(3)
    
        -- Get 6 potions
        local potionChunk = {}
        for j = 1, 7 do
            table.insert(potionChunk, table.remove(potions, 1))
        end
        local uniqueIdPotion = table.remove(potions, 1)

        if #potionChunk < 7 or not uniqueIdPotion then
            warn("‚ùå Not enough potions for Super Saru #" .. i)
            break
        end

        -- Feeding Args
        local args = {
            [1] = "__Enum_PetObjectCreatorType_2",
            [2] = {
                additional_consume_uniques = potionChunk,
                pet_unique = petUnique,
                unique_id = uniqueIdPotion
            }
        }

    
        local success, result = pcall(function()
            return CreatePetObject:InvokeServer(unpack(args))
        end)
    
        if success then
            print("üéâ Success: Fed Super Saru #" .. i)
        else
            warn("‚ùå Failed to feed Super Saru #" .. i, result)
        end
    
        task.wait(10)
    end
    
    print("üèÅ Feeding process complete!")

    task.wait(20)

-- auto neon here
    task.spawn(function()

        -- Optimized Neon + Mega auto-fuser
        -- Neon: 4 x same-kind, age==6, neon ~= true
        -- Mega: 4 x same-kind, age==6, neon == true
        -- Remote lives at API["PetAPI/DoNeonFusion"] (name includes a slash)
        
        local RS = game:GetService("ReplicatedStorage")
        local API = RS:WaitForChild("API", 10)
        assert(API, "[Fusion] API folder not found")
        
        local DoNeonFusion = API:WaitForChild("PetAPI/DoNeonFusion", 10)
        assert(DoNeonFusion, "[Fusion] PetAPI/DoNeonFusion remote not found")
        
        local ClientData = require(RS.ClientModules.Core.ClientData)
        local playerName = game.Players.LocalPlayer.Name
        
        local function inv()
            return ClientData.get_data()[playerName].inventory.pets
        end
        
        -- Build a set of UIDs that are currently in-use/equipped
        local function getActiveUids()
            local set = {}
            local act = ClientData.get_data()[playerName].idle_progression_manager
            local ap = act and act.active_pets
            if ap then
                for _, slot in pairs(ap) do
                    local ii = slot and slot.item_info
                    if ii then
                        local u = ii.unique or ii.id or ii.uid
                        if u then set[u] = true end
                        for _, v in pairs(ii) do
                            if type(v) == "table" then
                                local uu = v.unique or v.id or v.uid
                                if uu then set[uu] = true end
                            end
                        end
                    end
                end
            end
            return set
        end
        
        -- Robust extractor; tolerates flat or item_info schemas
        local function extract(p, key)
            local uid = p.unique or p.id or p.uid or key
            local kind = p.kind or (p.item_info and (p.item_info.kind or p.item_info.Kind))
            local props = p.properties or (p.item_info and p.item_info.properties) or {}
            local age = tonumber(props.age or props.Age)
            local neon = (props.neon == true) or (props.neon == "true")
            local locked = props.locked or props.Locked or props.favorite or props.Favorite
            return uid, kind, age, neon, locked
        end
        
        -- Fast bucket builder (no intermediate tables beyond two maps)
        local function buildBuckets(activeSet)
            local neonBuckets, megaBuckets = {}, {}
            for k, p in pairs(inv() or {}) do
                local uid, kind, age, neon, locked = extract(p, k)
                if uid and kind and age == 6 and not activeSet[uid] and not locked then
                    local bucket = neon and megaBuckets or neonBuckets
                    local arr = bucket[kind]
                    if arr then
                        arr[#arr + 1] = uid
                    else
                        bucket[kind] = { uid }
                    end
                end
            end
            return neonBuckets, megaBuckets
        end
        
        -- Single call shape first (array), with lightweight fallback to 4 args
        local function fuse4(a, b, c, d)
            local ok = pcall(function() DoNeonFusion:InvokeServer({a, b, c, d}) end)
            if ok then return true end
            ok = pcall(function() DoNeonFusion:InvokeServer(a, b, c, d) end)
            return ok
        end
        
        -- Fuse all full groups of 4 from each kind bucket (index stepping; no removes)
        local function fuseBuckets(buckets, label)
            local groups = 0
            for kind, arr in pairs(buckets) do
                local n = #arr - (#arr % 4) -- max multiple of 4
                for i = 1, n, 4 do
                    local a, b, c, d = arr[i], arr[i+1], arr[i+2], arr[i+3]
                    -- Minimal logging to reduce overhead; expand if debugging
                    -- print(("[%s] %s -> %s,%s,%s,%s"):format(label, kind, a, b, c, d))
                    local ok = fuse4(a, b, c, d)
                    if ok then
                        groups = groups + 1
                    else
                        warn(("[Fusion] %s failed for kind=%s on ids=%s,%s,%s,%s")
                            :format(label, tostring(kind), tostring(a), tostring(b), tostring(c), tostring(d)))
                        break -- avoid hammering if server rejects this kind right now
                    end
                    task.wait(1.0) -- gentle throttle
                end
            end
            return groups
        end
        
        -- Main loop
        while true do
            local active = getActiveUids()
            local neonBuckets, megaBuckets = buildBuckets(active)
        
            -- Quick counts without extra loops
            local function count(arrs) local c=0 for _,v in pairs(arrs) do c=c+#v end return c end
            -- print(("[Neon ready] %d | [Mega ready] %d"):format(count(neonBuckets), count(megaBuckets)))
        
            local neonFused = fuseBuckets(neonBuckets, "Neon")
            local megaFused = fuseBuckets(megaBuckets, "Mega")
            print(("[Fusion] Neon groups: %d | Mega groups: %d"):format(neonFused, megaFused))
        
            task.wait(450) -- run every 7.5 minutes
        end
    end)
    
    -- üîÅ Infinite trade loop
    while true do
        local pets = ClientData.get_data()[game.Players.LocalPlayer.Name].inventory.pets
        local availableBoxes = {}
    
        for _, pet in pairs(pets) do
            if pet.kind == "winter_2025_xmas_tree_sasquatch" or pet.id == "winter_2025_maine_coon" then
                table.insert(availableBoxes, pet.unique)
            end
        end
    
        if #availableBoxes == 0 then
            print("No kaijunior boxes found, retrying...")
            task.wait(10)
            continue
        end
    
        -- üîÑ One trade session (up to 18 boxes)
        local args = {
            [1] = game:GetService("Players"):WaitForChild(getgenv().PlayerToTrade)
        }
    
        game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("TradeAPI/SendTradeRequest"):FireServer(unpack(args))
        task.wait(5)
    
        local toTradeCount = math.min(100, #availableBoxes)
        for i = 1, toTradeCount do
            local args = {
                [1] = availableBoxes[i]
            }
            game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("TradeAPI/AddItemToOffer"):FireServer(unpack(args))
            task.wait(0.1)
        end
    
        -- Accept and confirm trade
        task.wait(5)
        game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("TradeAPI/AcceptNegotiation"):FireServer()
        task.wait(5)
        game:GetService("ReplicatedStorage"):WaitForChild("API"):WaitForChild("TradeAPI/ConfirmTrade"):FireServer()
    
        print("Traded", toTradeCount, "kaijunior boxes.")
        task.wait(5) -- wait before starting a new trade session
    end    

end
